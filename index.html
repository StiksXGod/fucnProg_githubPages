<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCP Documentation</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="documentation">
        <h1 id="main-title">Приёмы функционального программирования, как мы их использовали при выполнении курсовой, и как будем использовать в дальнейшей жизни. <br></h1>
        <h5 id="made-title">Made by PCP</h3>
        <div class="documentationwrapper">
            <p>Существует множество функциональных языков программирования, у каждого из них есть свои плюсы и минусы. При написании лабораторной работы, мы использовали мультипарадигмальный язык программирования из семейства языков .NET - F#. Среди его достоинств можно выделить следующие:<br></p>
        </div>
        <div class="table">
            <p>1.Безопасность типов: Код на F# безопасен в отношении типов и часто бывает более компактным, чем аналогичный код на C#.<br></p>
            <p>2.Неявные преобразования типов отсутствуют: F# не допускает неявных преобразований типов, что исключает ошибки, связанные с приведением типов.<br></p>
            <p>3.Функции высших порядков и обобщённое программирование: F# позволяет писать абстрактные обобщенные алгоритмы, управляющие параметризованными структурами данных.<br></p>
            <p>4.Константные значения по умолчанию: В F# все значения по умолчанию являются константами. Однако можно использовать изменяемые значения с помощью ключевого слова mutable.<br></p>
            <p>5.Чистые функции и упрощенное параллелирование: Большая часть кода в F# — это чистые функции, что упрощает отладку и распараллеливание программ.<br></p>
        </div>
        <div class="documentationwrapper">
            <p>Язык F# предлагает широкий спектр возможностей для реализации функциональных приемов в программировании. В рамках курсовой я продемонстрирую и расскажу про часть из них.<br></p>
        </div>
        <h2>
            Функции высшего порядка.
        </h2>
        <div class="documentationwrapper">
            <p>Функции высшего порядка (Higher-Order Functions) - это функции, которые могут принимать другие функции в качестве аргументов и/или возвращать функции в качестве результата. Они являются одним из ключевых концептов функционального программирования. В рамках лабораторной работы, при реализации интерпретатора подобный пример реализован в функции funof.Функции высшего порядка (Higher-Order Functions) - это функции, которые могут принимать другие функции в качестве аргументов и/или возвращать функции в качестве результата. Они являются одним из ключевых концептов функционального программирования. В рамках лабораторной работы, при реализации интерпретатора подобный пример реализован в функции funof.<br><br> Пример из кода:<br></p>
        </div>
        <div class="codewrapper">
            <code>
            let funof = function <br>
            &nbsp| "+" -> <br>
            &nbsp&nbsp(function <br>
            &nbsp&nbsp&nbsp| [Int(a); Int(b)] -> Int(a+b)<br>
            &nbsp&nbsp&nbsp| _ -> failwith "Invalid arguments for +"<br>
            &nbsp&nbsp)

            </code>
        </div>
        <h2>
            Рекурсии.<br>
        </h2>
        <div class="documentationwrapper">
            <p>В функциональном программировании рекурсия часто используется вместо циклов. Функции вызывают сами себя, чтобы решить подзадачи. Функция eval рекурсивно вычисляет выражения. Рекурсия используется вместо циклов для обработки структур данных и выполнения повторяющихся задач. Также рекурсивно реализованы функции evalFor и evalFunction.<br>
               <br> Примеры рекурсий на F#:
                <br></p>
        </div>
        <div class="codewrapper">
            <code>
            let rec factorial n =
                if n = 0 then 1
                else n * factorial (n - 1)

            // Пример использования
            let result = factorial 5 // результат: 120
            </code>
        </div>
        <h2>
            Хвостовая рекурсия.<br>
        </h2>
        <div class="documentationwrapper">
            <p>Хвостовая рекурсия - это специальный вид рекурсии, при котором рекурсивный вызов функции является последней операцией в функции. Это позволяет компилятору оптимизировать код и избежать переполнения стека, заменяя рекурсивные вызовы на итеративный цикл. В F# хвостовая рекурсия особенно важна, так как компилятор поддерживает оптимизацию хвостовой рекурсии (Tail Call Optimization), которая позволяет использовать рекурсию для обработки больших данных без опасения переполнения стека. В коде интерпретатора данный прием представлен  функциями evalFunction и evalFor, реализованы с использованием хвостовой рекурсии для оптимизации и предотвращения переполнения стека.<br>
                <br>Пример кода:
                <br></p>
        </div>
        <div class="codewrapper">
            <code>
            and evalFunction(body: Expr list, env: Map<Id, Expr>): Expr * Map<Id, Expr> =
                match body with
                | [] -> (Nothing, env)
                | expr::tail ->
                    let (ex, newEnv) = eval(expr, env)
                    match ex with
                    | Return(value) -> (value, env)
                    | _ -> evalFunction(tail, newEnv) 

            </code>
        </div>
        <h2>
            Замыкания.
            <br>
        </h2>
        <div class="documentationwrapper">
            <p>Замыкание (closure) в функциональном программировании - это функция, которая захватывает свое лексическое окружение в момент своего создания. Другими словами, замыкание содержит не только код функции, но и ссылку на окружение, в котором оно было определено. Это позволяет замыканию обращаться к переменным и параметрам из своего внешнего контекста, даже после того, как контекст, в котором оно было создано, вышел из области видимости.
                В F# замыкания очень распространены, поскольку они играют ключевую роль в функциональном стиле программирования. Вот пример создания и использования замыкания, использованные при создании парсера:                
                <br></p>
        </div>
        <div class="codewrapper">
            <code>
            and letParser : Parser<Expr, unit> =
                pipe2
                    (pstring "let" .>> spaces >>. identifierParser)
                    (pchar '=' .>> spaces >>. exprParser)
                    (fun varName expr -> Let(varName, expr))
            Пример при создании интерпретатора:
            let funof = function
                | "+" -> 
                    (function 
                        | [Int(a); Int(b)] -> Int(a+b)
                        | _ -> failwith "Invalid arguments for +"
                    )
                | "-" -> 
                    (function 
                        | [Int(a); Int(b)] -> Int(a-b)
                        | _ -> failwith "Invalid arguments for -"
                    )
                | _ -> failwith "Unknown operation"

            </code>
        </div>
        <h2>
            Чистые функции (pure functions).
            <br>
        </h2>
        <div class="documentationwrapper">
            <p>Чистая функция в функциональном программировании — это функция, которая:                
                <br></p>
        </div>
        <div class="table">
            <p>1.Возвращает результат: У чистой функции всегда есть возвращаемое значение. Она не изменяет состояние программы напрямую.
                <br></p>
            <p>2.Детерминирована: Для одинаковых входных данных чистая функция всегда возвращает одинаковый результат.<br></p>
            <p>3.Нет побочных эффектов: Чистая функция не изменяет состояние программы вне своего контекста. Она не изменяет внешние переменные, не делает записи в файлы, не взаимодействует с сетью и так далее.
                <br></p>
        </div>
        <div class="documentationwrapper">
            <p>В лабораторной работе данный прием представлен функцией Print и Read_int.              
                <br></p>
        </div>
        <h2>
            Ленивые вычисления.
            <br>
        </h2>
        <div class="documentationwrapper">
            <p>Ленивые вычисления (lazy evaluation) — это стратегия вычислений, при которой вычисление выражения откладывается до тех пор, пока его значение действительно не понадобится.
                <br>
                Преимущества ленивых вычислений:
                <br>
            </p>
        </div>
        <div class="table">
            <p>1.Экономия ресурсов: Вычисления происходят только в случае реальной необходимости, что позволяет избежать излишних расходов памяти и процессорного времени.
                <br></p>
            <p>2.Бесконечные структуры данных: Ленивые вычисления позволяют работать с бесконечными или потенциально бесконечными структурами данных, такими как потоки (streams) или бесконечные списки.
                <br></p>
            <p>3.Увеличение производительности: В некоторых случаях ленивые вычисления могут сделать программу более производительной за счет отсроченных вычислений.
                <br>
            </p>

        </div>
        <div class="documentationwrapper">
            <p>В лабораторной работе данный прием представлен функцией Print и Read_int.              
                <br>
                Пример ленивых вычислений на F#:
                <br>
            </p>
        </div>
        <div class="codewrapper">
            <code>
            let rec factorial n =
                if n = 0 then 1
                else n * factorial (n - 1)
            
            let rec factorialLazy n =
                seq { yield 1
                      for i in 1 .. n do
                          yield i * Seq.nth (Seq.init i id) (i - 1) } |> Seq.nth (n-1)
            
            let result = factorial 5
            let resultLazy = factorialLazy 5
            </code>
        </div>
        <h2>
            Лямбда-функции.
            <br>
        </h2>
        <div class="documentationwrapper">
            <p>В F# лямбда-функции представляются с помощью ключевого слова fun. Они могут быть использованы для создания анонимных функций, которые могут быть переданы в функции высшего порядка или использованы в качестве локальных функций.
                <br>
            </p>
        </div>
        <div class="codewrapper">
            <code>
            // Пример лямбда-функции для вычисления квадрата числа
            let square = fun x -> x * x

            // Использование лямбда-функции
            printfn "%d" (square 5) // Вывод: 25

            // Пример использования лямбда-функции в функции высшего порядка
            let numbers = [1; 2; 3; 4; 5]
            let squares = List.map (fun x -> x * x) numbers
            </code>
        </div>
        <h2>
            Как мы будем использовать приемы функционального программирования в дальнейшем.
            <br>
        </h2>
        <div class="documentationwrapper">
            <p>Функциональные приемы универсальны. Их применение не ограничивается функциональными языками программирования. Некоторые давно перетекли в императивные языки программирования. Множество приемов и концепций из функциональных языков программирования были заимствованы и интегрированы в императивные языки. Вот некоторые из них:
                <br>
            </p>
        </div>
        <div class="table">
            <p>1.Лямбда-функции: Использование анонимных функций (лямбда-функций) было заимствовано из функциональных языков и внедрено во многие императивные языки, такие как Python, Java, C# и другие.
                <br></p>
            <p>2.Функции высших порядков: Возможность передавать функции как аргументы и возвращать их из других функций также стала распространенной практикой в императивных языках. Это позволяет писать более компактный и выразительный код.
                <br></p>
            <p>3.Неизменяемость данных: Концепция неизменяемости данных, где данные не могут быть изменены после создания, была заимствована из функциональных языков и интегрирована в некоторые императивные языки. Например, в Java неизменяемые объекты могут быть созданы с помощью ключевого слова final.
                <br>
            </p>
            <p>4.Рекурсия: Хотя рекурсия в основном ассоциируется с функциональным программированием, многие императивные языки также поддерживают рекурсию в своих функциональных частях.
                 <br>
            </p>
            <p>5.Композиция функций: Возможность объединять функции в цепочку, называемую композицией функций, стала доступной и в некоторых императивных языках. Это позволяет писать более элегантный и выразительный код.
                <br>
            </p>
            <p>6.Функциональные типы данных: Некоторые императивные языки включают в себя структуры данных, такие как списки, карты (ассоциативные массивы), и т.д., которые имеют функциональные свойства, такие как неизменяемость.
                <br>
            </p>
        </div>
        <div class="documentationwrapper">
            <p>Дальнейшее развитие функциональных языков ведет к неизбежному созданию новых приемов, которые, в свою очередь, распространятся дальше.  Сфера применения функциональных языков не ограничена, поэтому появление новых приемов неизбежно.
                <br>
            </p>
        </div>
    </div>
</body>
</html>